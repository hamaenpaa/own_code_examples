/****************************************************************************//*  **        M J O N O T . C**** Yleisi³ merkkijonojen k³sittelyyn liittyvi³ aliohjelmia.               **** Aliohjelmat:**    tee_jono               - luo uuden merkkijonon jonne jono kopioidaan    -**    kopioi_jono            - kopioi kork. annetun m³³r³n merkkej³           -**    liita_jono             - liitt³³ jonon toisen per³³n, tulos**                             korkeintaan max.pituus mittainen               -**    f_lue_jono             - lukee tiedostosta merkkijonon                  -**    alusta_lue_jono        - alustaa merkkijonon lukemisen                  -**    lue_jono               - lukee p³³tteelt³ merkkijonon                   -**    lue_jono_oletus        - lukee p³³tteelt³ merkkijonon.**                             N³yttään tulostetaan haluttu viesti ja**                             jonon oletusarvo, mik³li painetaan RET         -**    lue_kokluku_oletus     - luetaan kokonaisluku, jolle k³ytet³³n**                             oletusarvoa mik³li heti painetaan RET          -**    poista_alkutyhjat      - poistaa merkkijonon alussa olevat v³lilyännit  -**    poista_lopputyhjat     - poistaa merkkijonon lopussa olevat v³lil.      -**    poista_2_tyhjat        - muuttaa merkkijonossa kaikki per³kk³iset**                             v³lilyännit yhdeksi v³lilyänniksi              -**    poista_tyhjat          - poistaa alusta ja lopusta kaikki sek³**                             muualta moninkertaiset v³lilyännit             -**    poista_alku_ja_2_tyhjat- poistaa alusta ja 2x tyhj³t                    -**    isoksi                 - muuttaa kirjaimen isoksi kirjaimeksi huomioiden**                             skandit                                        -**    pieneksi               - muuttaa pieneksi huomioiden skandit            -**    jono_isoksi            - muuttaa jonon kaikki merkit isoiksi            -**    jono_pieneksi          - muuttaa jonon kaikki merkit pieniksi           -**    jono_alku_isoksi       - muuttaa jonon kaikki sanojen alut isoiksi**                             ja kaikki muut pieniksi                        -**    jono_1_isoksi          - muuttaa jonon 1. kirjaimen isoksi              -**    wildmat                - vertaa onko sana == maski, miss³ maskissa**                             voi olla jokeri-merkkej³ (* tai ?)             -**    onko_samat             - ensin muutetaan jonot isoiksi ja poistetaan**                             tyhj³t ja sitten wildmat**                             (eli "  Kalle " == "    k*  ")                 -**    palanen                - ottaa merkkijonosta seuraavan erotinmerkkien**                             m³³r³³m³n palasen                              -**    laske_merkit           - laskee annettujen merkkien esiintymism³³r³n**                             merkkijonossa                                  -**    paikka                 - palauttaa kirjaimen 1. indeksin merkkijonossa  -**    tayta_valit            - t³ytt³³ syätän "A-F" muotoon "ABCDEF"          -**    joku_jono              - vastaa kysymykseen onko "EY" joku jonoista**                             "EU|EY|EL"                                     -**    joku_jono_func         - kuten edell³, mutta vertailufunktio voidaan**                             antaa itse, esim**                               joku_jono("EU","E?|USA",wildmat) => 1        -**    jono_arvosanaksi       - muuttaa merkkijonon "7-" reaaliluvuksi 6.75    -**    arvosana_jonoksi       - muuttaa reaaliluvun 6.75 merkkijonoki "7-"     -**    sallituissa            - paluttaa -1 jos tutkittavan jonon kaikki**                             merkit ovat annetussa joukossa, muuten**                             1. v³³r³n merkin indeksin                      -**    poista_merkit          - poistaa jonosta kaikki valitut merkit          -**    poista_alusta          - poistaa merkkej³ jonon alusta                  -**    lisaa_alkuun           - lis³³ merkkej³ jonon alkuun                    -**    lisaa_merkki           - lis³³ merkin merkkijonon valittuun kohtaan     -**    vaihda_jonot           - vaihtaa jonossa merkit toisiksi**                               ^ - rivin alussa tarkoittaa, etta**                                   vaihto tehdaan vain rivin alusta         -**    vaihda_merkit          - vaihtaa jonossa yksitt³iset merkit**                             toisiksi                                       -**    muunna_C_symbolit      - muuttaa \t, \n ja \0x61 muotoiset**                             C-symbolit vastaaviksi merkeiksi               -**    jonossa_vain_merkit    - poistaa jonosta kaikki ne merkit, jotka**                             eiv³t ole valitussa joukossa                   -**** Kaikissa aliohjelmissa on varauduttu siihen, ett³ niit³ kutsutaan** NULL osoittimella ja kukin niist³  yritt³³ toimia t³lläin jotenkin** j³rkev³sti.*/#include <stdio.h>#include <stdlib.h>#include <string.h>#include <ctype.h>#include "mjonot.h"const char *VALIMERKIT=" .,-;:?!";/****************************************************************************/char                      /* = jonon kopion osoite                          */*tee_jono(                /* NULL = ei voida kopioida                       */  const char *jono        /* s   Kopioitava merkkijono                      */)/*** Funktiolla varataan jonon kokoinen uusi tila ja jono kopioidaan sinne.** Palautetaan uuden jonon osoite.**** Kutsuu:    malloc----------------------------------------------------------------------------*/{  char *uusi;  if ( jono == NULL ) return NULL;  if ( (uusi = malloc(strlen(jono)+1)) == NULL ) return NULL;  return (strcpy(uusi,jono));}/****************************************************************************/int                       /*                                                */kopioi_jono(              /* 0 = onnistui, muu = kaikki ei mahtunut         */  char *tulos            ,/* t   Jono jonne kopioidaan                      */  int  max_koko          ,/* s   Tuloksen maksimikoko                       */  const char *jono        /* s   Kopioitava merkkijono                      */)/*** Funktiolla kopioidaan merkkijono.  Mik³li jono ei mahdu sille** varattuun tilaan, katkaistaan jono.**** Kutsuu:    strncpy----------------------------------------------------------------------------*/{ /*  strncpy(tulos,jono,max_koko);  if ( strlen(jono)>=max_koko ) {    tulos[max_koko-1]=0;    return 1;  }  return 0;  */  int i;  const char *p=jono;  tulos[0] = 0;  if ( jono == NULL ) return 0;  for (i=0; *p && i<max_koko-1; i++, p++)    tulos[i] = *p;  tulos[i] = 0;  return (*p);}/****************************************************************************/int                       /*                                                */liita_jono(               /* 0 = onnistui, 1 = kaikki ei mahtunut           */  char *tulos            ,/* s,t Jono jonne liitet³³n                       */  int  max_koko          ,/* s   Tuloksen maksimikoko                       */  const char *jono        /* s   Kopioitava merkkijono                      */)/*** Funktiolla liitet³³n  merkkijono tuloksen per³³n.  Mik³li jono ei mahdu** sille varattuun tilaan, katkaistaan jono.----------------------------------------------------------------------------*/{  int i; const char *p;  if ( jono == NULL ) return 0;  for (i=strlen(tulos), p=jono; i<max_koko-1; i++, p++) {    if ( !(tulos[i]=*p) ) break;  }  tulos[i]=0;  return (*p != 0);}/****************************************************************************/int                       /*  2 = jono syätettiin                           */f_lue_jono(               /*  1 = jono ei mahtunut                          */                          /*  0 = painettiin heti RETURN                    */                          /* -1 = <EOF>                                     */                          /* -2 = virhe syätäss³                            */  FILE *f,                /* s   Tiedosto josta luetaan                     */  char *jono,             /* t   Merkkijono johon luetaan                   */  int  max_pituus         /* s   Luettavien merk. max.lkm+1 (tila \0)       */)/*** Funktiolla luetaan tiedoston yhdelt³ rivilt³ korkeintaan** max_pituus -mittainen merkkijono.  Jonoon ei tule \n -merkki³.** Tiedoston ollessa loppu palautetaan -1 mutta itse jonoon ei kosketa.** Mik³li rivill³ ei yht³³n merkki³, palautetaan 0 samoin kuin jonona.** Rivin loppuosa, joka ei mahdu jonoon h³vitet³³n.**** Syättä:    tiedostosta** Tulostus:  n³ytälle jos stdin** Tekij³:    Vesa Lappalainen** Pvm:       9.10.1991** Esimerkki: Kutsu f_lue_jono(f,jono,8)**   Tiedostossa rivit:                     palauttaa**     1234567890123456789              jonon pituus f_lue_jono   jono**     Kissa puussa                          7          1         Kissa p\0**     istuu                                 5          2         istuu\0**                                           0          0         \0**     ja ihmettelee.                        7          1         ja ihme\0**     Joo!<EOF>                             4          2         Joo!\0**- seuraava kutsu                           4         -1         Joo!\0----------------------------------------------------------------------------*/{  int jonon_pituus,c;  if ( jono == NULL ) return VIRHE_SYOTOSSA;  if ( feof(f) ) return TIEDOSTO_LOPPU;  if ( fgets(jono,max_pituus,f)==NULL ) return VIRHE_SYOTOSSA;  jonon_pituus = strlen(jono);  if ( jono[jonon_pituus-1]=='\n' ) { /* Poistetaan mahd. \n                */    jonon_pituus--;    jono[jonon_pituus]=0;    if ( jonon_pituus==0 ) return OLETUS;    return SYOTTO_OK;  }  /* Erikoistapaukset:                                                      */  /* Jos jono loppui ja tiedosto samalla, ei tietenk³³n ole \n ja mahtui    */  if ( feof(f) ) return SYOTTO_OK;  /* Jos jonosta loppui tila samalla kun vain \n j³i lukematta              */  c=fgetc(f); if (c=='\n') return SYOTTO_OK;  while ( ((c=fgetc(f))!=EOF) && (c!='\n') );    /* Poistetaan rivin loppu. */  return EI_MAHDU;}static lue_jono_tyyppi lue_jono_funk = NULL;/****************************************************************************/lue_jono_tyyppi           /* Edellisen lukufunktion osoite                  */alusta_lue_jono(          /*                                                */  lue_jono_tyyppi uusi    /* s   Uuden lukufunktion osoite                  */)/*** Funktiolla voidaan vaihtaa lue_jono-funktion k³ytt³m³n funktion osoitetta** Lukufunktion t³ytyy paluttaa vastaavia arvoja kuin f_lue_jono** ja sen parametrilistassa on jono ja sen maksimipituus (kuten lue_jono).** Jos esimerkiksi halutaan k³ytt³³ lyhenteit³ k³ytt³v³³ lukufunktiota,** kutsutaan jossakin kohti ohjelmaa (ennenkuin muutosta tarvitaan):**   alusta_lue_jono(lue_lyhenne_jono);**** Jos v³lill³ halutaan lukea ehdottomasti alkuper³isell³ lue_jono** funktion toteutuksella, kutustaan esim:**   vanha = alusta_lue_jono(NULL);**   paluu = lue_jono(s,maxp);**   alusta_lue_jono(vanha);**** HUOM!  Jos t³t³ funktiota ei kutsuta ohjelman aikana, k³ytet³³n**        alkuper³ist³ lue_jono-toteutusta (eli f_lue_jono(stdin,...)****----------------------------------------------------------------------------*/{  lue_jono_tyyppi vanha = lue_jono_funk;  lue_jono_funk = uusi;  return vanha;}/****************************************************************************/int lue_jono(char *jono,int max_pituus)/*** Funktiolla luetaan p³³tteelt³ yhden rivin mittainen merkkijono.** Muuten ks. f_lue_jono.** Syättä:    p³³tteelt³** Tulostus:  n³ytälle----------------------------------------------------------------------------*/{  if ( lue_jono_funk ) return lue_jono_funk(jono,max_pituus);  fflush(stdin);  /* TAMA EI TOIMI VALTTAMATTA KAIKISSA KONEISSA!           */  return f_lue_jono(stdin,jono,max_pituus);}/****************************************************************************/int                       /*  2 = jono syätettiin                           */lue_jono_oletus(          /*  1 = jono ei mahtunut                          */                          /*  0 = tyhj³ rivi                                */                          /* -1 = <EOF>                                     */                          /* -2 = virhe syätäss³                            */  const char *hopute,     /* s   Teksti joka tulostetaan kysymykseksi.      */  int  oletus_alku,       /* s   Sarake josta oletusarvo alkaa. (0=heti)    */  int  jonon_alku,        /* s   Sarake johon > tulee. (0=heti.)            */  const char *oletus,     /* s   Merkkijonon oletusarvo.                    */  char *jono,             /* t   Palautettava merkkijono.                   */  int max_pituus          /* s   Palautettavan jonon maksimipituus.         */)/*** Funktiolla luetaan p³³tteelt³ yhden rivin mittainen merkkijono.** Mik³li vastataan pelkk³ [Ret] palautetaan oletusjono.** Hoputteeksi tulostetaan teksti 'hopute (oletus) >'** Negatiiviset arvot oletus_alku ja jonon_alku sarakkeilla tarkoittavat** et³isyytt³ (itseisarvo) edellisest³ merkist³.** Muuten ks. f_lue_jono** Syättä:    p³³tteelt³** Tulostus:  n³ytälle** Kutsuu:    f_lue_jono** Esimerkki:**  Kutsu: lue_jono_oletus("Anna j³senen nimi",19,33,"Ankka Aku",nimi,30)**                   19            33** Anna j³senen nimi (Ankka Aku)   >Ankka Tupu**               Palautetaan: 2 sek³ nimi = "Ankka Tupu"**** Jos m³³ritelty vakio USE_CONSOLE, niin t³lläin oletusta ei tulosteta,** vaan toivotaan lue_jonon olevan sellaista tyyppi³, ett³ se tulostaa** alkuper³isen arvon n³yttään editoitavaksi (ks. alusta_lue_jono).----------------------------------------------------------------------------*/{  char oletus_kopio[80]; /* Kopio oletusjonosta jotta oletus voi olla jono  */  int  oletus_pituus,hopute_pituus,       tyhjat_h_s,tyhjat_s_v,palautus;  if ( hopute == NULL ) hopute = "";  if ( oletus == NULL ) oletus = "";  kopioi_jono(N_S(oletus_kopio),oletus);  hopute_pituus = strlen(hopute);  oletus_pituus = strlen(oletus_kopio);  /* Tyhji³ hoputetekstin ja oletuksen vasemman sulun v³liin                */  tyhjat_h_s = oletus_alku - hopute_pituus - 1;  if ( tyhjat_h_s <= 0 ) tyhjat_h_s = 1;  if ( oletus_alku < 0 ) tyhjat_h_s = -oletus_alku;  /* Tyhji³ oletuksen oikean sulun ja v³k³sen v³liin                        */  tyhjat_s_v = jonon_alku - (hopute_pituus+tyhjat_h_s+1+oletus_pituus+1) - 1;  if ( tyhjat_s_v <= 0 ) tyhjat_s_v = 0;  if ( jonon_alku < 0 ) tyhjat_s_v = -jonon_alku;  kopioi_jono(jono,max_pituus,oletus_kopio);#ifndef USE_CONSOLE  printf("%s"    "%*s"         "(%s)"       "%*s"        ">",          hopute,tyhjat_h_s,"",oletus_kopio,tyhjat_s_v,"");  if ( (palautus = lue_jono(jono,max_pituus)) != OLETUS ) return palautus;  kopioi_jono(jono,max_pituus,oletus_kopio);#else  printf("%s"    "%*s"         ">",          hopute,tyhjat_h_s,"");  lue_jono(jono,max_pituus); palautus = SYOTTO_OK;  if ( strcmp(jono,oletus_kopio) != 0 ) return palautus;#endif  return OLETUS;}/****************************************************************************/int                       /*  2 = syätettiin                                */lue_kokluku_oletus(       /*  1 = annettiin liian iso syättä                */                          /*  0 = tyhj³ rivi                                */                          /* -1 = <EOF>                                     */                          /* -2 = virhe syätäss³                            */  int oletus_luku,        /* s   Luvun oletusarvo.                          */  int *luku               /* t   Luettu luku.                               */)/*** Funktiolla luetaan kokonaisluku.** Mik³li painetaan heti CR tai j³rkev³³ lukua ei ole, palautetaan oletusarvo.** Kutsuu:    lue_jono----------------------------------------------------------------------------*/{  int  palautus,i;  char st[20];  if ( luku == NULL ) return VIRHE_SYOTOSSA;  *luku = oletus_luku;  sprintf(st,"%d",oletus_luku);  if ( (palautus=lue_jono(st,20)) <= OLETUS ) return palautus;  if ( !sscanf(st,"%d",&i) ) return VIRHE_SYOTOSSA;  *luku = i;  return palautus;}/****************************************************************************/char                      /*                                                */*poista_alkutyhjat(       /* =   Muutettu jono                              */  char *jono              /* t   Muutettu jono                              */)/*** Funktiolla poistetaan merkkijonosta alussa olevat v³lilyännit**** Algoritmi: Siirret³³n jonoa alkutyhjien verran taaksep³in.** Esimerkki: "   kissa " -> "kissa "----------------------------------------------------------------------------*/{  int i,l;  if ( jono == NULL ) return "";  for (i=0; jono[i]==' '; i++);          /* Lasketaan alkutyhjien lukum³³r³ */  l = strlen(&jono[i]);  memmove(jono,&jono[i],l+1);  return jono;}/****************************************************************************/char                      /*                                                */*poista_lopputyhjat(      /* =   Muutettu jono                              */  char *jono              /* s,t Muutettu jono                              */)/*** Funktiolla poistetaan merkkijonosta lopussa olevat v³lilyännit**** Algoritmi: Siirret³³n merkkijono loppumerkki 1. ei-tyhj³n per³³n.** Esimerkki: " kissa   " -> " kissa"----------------------------------------------------------------------------*/{  int i;  if ( jono == NULL ) return "";  for (i=strlen(jono)-1; i>=0 && jono[i]==' '; i--)    jono[i]=0;  return jono;}/****************************************************************************/char                      /*                                                */*poista_2_tyhjat(         /* =   Muutettu jono                              */  char *jono              /* s,t Muutettu jono                              */)/*** Funktiolla poistetaan merkkijonosta moninkertaiset v³lilyännit.**** Algoritmi: K³ytet³³n kahta osoitinta luku ja kirjoitus,**            Merkki kopioidaan lukupaikasta kirjoituspaikkaan kun**            ei ole moninkertaista tyhj³³, t³lläin myäs kasvatetaan**            kirjoituspaikkaa.**            luku-osoitinta siirret³³n aina eteenp³in.** Esimerkki: "k    is   sa" -> "k is sa"**               ^  ^**               k  l----------------------------------------------------------------------------*/{  int tyhjia=0;  char *l=jono,*k=jono;  if ( jono == NULL ) return "";  while ( *l ) {    if ( *l == ' ') tyhjia++;    else tyhjia = 0;    if ( tyhjia <= 1 ) { *k = *l; k++; }     /* Jollei 2-tyhj³, kopioidaan! */    l++;  }  *k = 0;  return jono;}/****************************************************************************/char                      /*                                                */*poista_tyhjat(           /* =   Muutettu jono                              */  char *jono              /* s,t Muutettu jono                              */)/*** Funktiolla poistetaan merkkijonosta kaikki alku ja lopputyhj³t** sek³ moninkertaiset tyhj³t jonon keskelt³.**** Kutsuu:    poista_alkutyhjat**            poista_lopputyhjat**            poista_2_tyhjat** Esimerkki: "    kis   sa    " -> "kis sa"----------------------------------------------------------------------------*/{  poista_alkutyhjat(jono);  poista_lopputyhjat(jono);  return poista_2_tyhjat(jono);}/****************************************************************************/char *poista_alku_ja_2_tyhjat(char *s){  poista_alkutyhjat(s);  poista_2_tyhjat(s);  return s;}/****************************************************************************/char                      /*                                                */isoksi(                   /* Muutetaan kirjain vast. isoksi kirjaimeksi.    */  char c                  /* s   Muutettava kirjain.                        */)/*** Funktiolla muutetaan pienet kirjaimet isoiksi.  Myäs skandit toimivat** Algoritmi: K³sitell³³n skandit erikoistapauksena.----------------------------------------------------------------------------*/{  switch (c) {    case '³': return 'Ú';    case 'ä': return 'ú';    case 'º': return '¶';  }/* N³in:  if ( c<'a' ) return c;  if ( c>'z' ) return c;  return c-('a'-'A');tai: */  return (char)toupper(c);}/****************************************************************************/char                      /*                                                */pieneksi(                 /* Muutetaan kirjain vast. pieneksi kirjaimeksi.  */  char c                  /* s   Muutettava kirjain.                        */)/*** Funktiolla muutetaan isot kirjaimet pieniksi.  Myäs skandit toimivat** Algoritmi: K³sitell³³n skandit erikoistapauksena.----------------------------------------------------------------------------*/{  switch (c) {    case 'Ú': return '³';    case 'ú': return 'ä';    case '¶': return 'º';  }/*  if ( c<'A' ) return c;  if ( c>'Z' ) return c;  return c+('a'-'A');*/  return (char)tolower(c);}/****************************************************************************/char                      /*                                                */*jono_pieneksi(           /* Muutetaan jono pienill³ kirjoitetuksi.         */  char *jono              /* s,t Muutettava jono.                           */)/*** Funktiolla muutetaan merkkijonon isot kirjaimet pieniksi.  Myäs skandit.** Kutsuu:    pieneksi----------------------------------------------------------------------------*/{  char *p;  if ( jono == NULL ) return "";  for (p=jono; *p; p++) *p=pieneksi(*p);  return jono;}/****************************************************************************/char                      /*                                                */*jono_isoksi(             /* Muutetaan jono isoilla kirjoitetuksi.          */  char *jono              /* s,t Muutettava jono.                           */)/*** Funktiolla muutetaan merkkijonon pienet kirjaimet isoiksi.  Myäs skandit.** Kutsuu:    isoksi----------------------------------------------------------------------------*/{  char *p;  if ( jono == NULL ) return "";  for (p=jono; *p; p++) *p=isoksi(*p);  return jono;}/****************************************************************************/char                      /*                                                */*jono_alku_isoksi(        /* Muutetaan jonon sanojen alut isoiksi, muut pien*/  char *jono              /* s,t Muutettava jono.                           */)/*** Funktiolla muutetaan jonon sanojen 1. kirjaimet isoiksi.  Sanan kaikki** muut muutetaan pieniksi.**** Kutsuu:    isoksi**            pieneksi** Algoritmi: V³limerkkien j³lkeen sanan pituus = 0.  Muuten ++**            Jos sanan pituus on 1 muutetaan aina**            isoksi.  Muuten pieneksi.** Esimerkki: "iso paha SUSI" -> "Iso Paha Susi"----------------------------------------------------------------------------*/{  char *p; int sanan_pituus=0;  if ( jono == NULL ) return "";  for (p=jono; *p; p++) {    if ( strchr(VALIMERKIT,*p) != NULL ) sanan_pituus = 0;    else sanan_pituus++;    if ( sanan_pituus == 1 ) *p=isoksi(*p);    else *p=pieneksi(*p);  }  return jono;}/****************************************************************************/char                      /*                                                */*jono_1_isoksi(           /* Muutetaan jonon 1. kirjain isoiksi, muita ei   */  char *jono              /* s,t Muutettava jono.                           */)/*** Funktiolla muutetaan jonon 1. kirjain isoiksi.  Muihin ei kosketa.**** Kutsuu:    isoksi** Esimerkki: "iso paha SUSI" -> "Iso paha SUSI"----------------------------------------------------------------------------*/{  if ( jono == NULL ) return "";  jono[0] = isoksi(jono[0]);  return jono;}/****************************************************************************/int                       /*                                                */wildmat(                  /* 0 = jono t³sm³³ maskiin                        */                          /* 1 = jono ei t³sm³³ maskiin                     */  const register char *s ,/* s   Tutkittava jono                            */  const register char *m  /* s   Maski, johon jonoa verrataan               */)/*** Funktiolla tutkitaan t³sm³³kä annettu jono verrattavaan maskiin.** Maski saa sis³lt³³ seuraavia erikoismerkkej³:**   * vastaa 0-n merkki³**   ? vastaa mit³ tahansa yht³ merkki³**** Algoritmi: Kysymysmerkki ja tavallinen kirjain normaalisti**            Jos tulee vastaan t³hti joka ei ole jonon lopussa,**            niin ongelmahan on oikeastaan**            (koska t³h³n asti kaikki on ollut oikein)**            "Onko loppujono sama kuin toisen jonon loppu JOSTAKIN**             kohdasta alkaen"?**            Siis kokeillaan sovittaa loppujonoa aliohjelman itsens³**            (rekursio) avulla kaikkiin mahdollisiin loppupaikkoihin.** Esimerkki: s = "Kissa" m = "*ss*" -> 0**                          = "*ss"  -> 1** Vika alkuper³isess³ algoritmissa:**   Jos m="*a" ja s="" ja s[1]!=0 (mik³ tietysti sallittua!)**   niin vastaus oli 0.**   Korjattu 29.1.1994/vl muuttamalla rekursion j³lkeinen**             if (!*++s) return 1;**   muotoon**             if (!*s || !*++s) return 1;----------------------------------------------------------------------------*/{  while (*m) {                    /* Jos kokeiltavaa jonoa on j³ljell³      */    if (*m == '?') {              /* Jos kysymysmerkki, niin kaikki kelpaa  */      if (!*s) return 1;          /* paitsi jos jono on loppunut!           */    }    else if (*m == '*') {         /* Jos * niin katsotaan onko viimeinen    */      if (*++m)                   /* Jollei * viimeinen, niin kokeillaan    */        while (wildmat(s, m))     /* loppujonoa jokaiseen eri paikkaan.     */          if (!*s || !*++s) return 1;/* Jos jono loppuu kesken ei t³sm³³!   */      return 0;                   /* Muuten samat (* viimeinen tai loppujono*/    }                             /* t³sm³si)                               */    else if (*s != *m)            /* Jos samat merkit niin tietysti OK!     */      return 1;    s++; m++;                     /* Kummassakin jonossa eteenp³in          */  }  return *s;                      /* Jos jono loppui yht³aikaa, niin OK!    */}/****************************************************************************/int                       /* 1 = erit                                       */onko_samat(               /* 0 = samat                                      */  const char *jono       ,/* s   Tutkittava merkkijono                      */  const char *maski       /* s   Verrattava jono, joka saa sis³lt³³ * ja ?  */)/*** Funktiolla tutkitaan onko jono ja maski isoiksi muutettuina samoja.**** Kutsuu:    jono_isoksi**            poista_tyhjat**            wildmat----------------------------------------------------------------------------*/{  char ijono[80],imaski[80];  kopioi_jono(N_S(ijono),jono); kopioi_jono(N_S(imaski),maski);  return wildmat(jono_isoksi(poista_tyhjat(ijono)),                 jono_isoksi(poista_tyhjat(imaski)));}/****************************************************************************/char                      /*                                                */*palanen(                 /* Osoitin merkkijonon palaseen.                  */  char *jono             ,/* s   P³tkitt³v³ jono, turmeltuu!                */  const char *erottimet  ,/* s   Merkit joiden kohdalta katkaistaan.        */  int  *jaljella          /* t   Paljonko jonoa on viel³ j³ljell³ (-1 loppu)*/)/*** Funktiolla p³tkit³³n merkkijonoa osiin.  1. kutsukerralla v³litet³³n** tutkittava jono ja t³m³n j³lkeen seuraavilla NULL osoitin.** Funktio vaihtaa läyt³m³ns³ erotinmerkti NUL-merkeiksi!**** Muuttuu:   jono** Algoritmi:** Esimerkki:       012345678901234**            jono="Aku|Ankka||12" erottimet="|"**            1. kutsu palanen(jono,"|",&j) -> "Aku"  , j=9**            2. kutsu palanen(NULL,"|",&j) -> "Ankka", j=3**            3. kutsu palanen(NULL,"|",&j) -> ""     , j=2**            4. kutsu palanen(NULL,"|",&j) -> "12"   , j=0**            5. kutsu palanen(NULL,"|",&j) -> ""     , j=-1----------------------------------------------------------------------------*/{  static char *st;  static int p1,p2,pit;  if (jono) {      /* 1. kutsukerta, alustetaan apumuuttujat */    st  = jono;    pit = strlen(jono);    p1  = 0;  }  else    p1  = p2+1;    /* Muilla kerroilla jatketaan siit³ mihin viim. j³³tiin. */  if ( p1 > pit ) {    *jaljella = -1;    return st+pit; /* Tyhj³ merkkijono, kun osoitetaan jonon NUL-tavuun.    */  }  p2 = p1+strcspn(st+p1,erottimet);  st[p2] = 0;  *jaljella = pit-p2;  return st+p1;}/****************************************************************************/int                       /*                                                */laske_merkit(             /* Merkkien lukum³³r³ jonossa.                    */  const char *jono       ,/* s   Jono josta merkkej³ lasketaan.             */  const char *merkit      /* s   Merkit joita etsit³³n.                     */)/*** Funktiolla lasketaan annettujen merkkien yhteinen esiintymism³³r³** merkkijonossa.**** Esimerkki: jono = "Kissa" merkit = "is"  -> laske_merkit = 3**            jono = "Kissa" merkit = "ss"  -> laske_merkit = 2----------------------------------------------------------------------------*/{  int maara=0; char const *p=jono;  if ( jono   == NULL ) return 0;  if ( merkit == NULL ) return 0;  while (*p) if (strchr(merkit,*p++)) maara++;  return maara;}/****************************************************************************/int                       /* -1   = ei läydy                                */paikka(                   /* muut = 1. läytymispaikan indeksi               */  const char *jono       ,/* s   Jono josta merkki³ etsit³³n.               */  char merkki             /* s   merkki jota etsit³³n                       */)/*** Funktiolla palautetaan etsitt³v³n merkin 1. indeksi merkkijonossa.**** Esimerkki: jono = "Kissa"  merkki='s'  -> 2**            jono = "Koira"  merkki='s'  -> -1----------------------------------------------------------------------------*/{  const char *p;  if ( jono == NULL ) return -1;  if ( merkki == 0 ) return -1;  p = strchr(jono,merkki);  if (p) return (int)(p-jono);  return -1;}/****************************************************************************/char*tayta_valit(           /* Palauttaa osoitteen muutettuun mjonoon.          */  char *tulos         , /* t   Muutettu merkkijono                          */  int max_koko        , /* s   Tulosjonon maksimikoko                       */  const char *jono    , /* s   Muutettettava jono                           */  const char *mista     /* s   Jono, josta t³yttä otetaan.  Jos NULL, niin  */                        /*     tarkoittaa kaikkia ASCII-merkkej³            */)/*** Funktiolla t³ydennet³³n mjonossa olevat v³lit.**** Tekij³:    Vesa Lappalainen** Pvm:       19.3.1992**            24.3.1992  lis³tty max_koko parametri/vl**            11.12.1993 lis³tty mista-jono** Esimerkki: mista = NULL**            jono = "1-5"  -> tulos = "12345"**            jono ="-!"    -> tulos = " !"**            jono ="K-"    -> tulos = "KLMNOPQRSTU..."**            jono "1-4A-D" -> tulos "1234ABCD"**            jono "1--5"   -> tulos "15"**            jono "3-1"    -> tulos "31"**            mista = "KISAT"**            jono = "K-"   -> tulos = "KISAT"**            jono = "VI-A" -> tulos = "VISA"**            jono = "A-F"  -> tulos = "AF"**            jono = "L-A"  -> tulos = "LA"**            jono = "-A"   -> tulos = "KISA"** Algoritmi: kopioidaan merkki kerrallaan tulosjonoon**            kunnes tulee -**              laitetaan tulosjonoon merkit edellinen+1 ... seuraava-1**              jatketaan alusta kunnes jono loppuu----------------------------------------------------------------------------*/{#define ONKO_LOPETUS if (t>loppu) { tulos[loppu]=0; return tulos; }  int j=0;  int t=0, loppu=max_koko-1;  unsigned char edellinen=' '-1;  int c,ed,seuraava;  tulos[0] = 0;  if ( tulos == NULL ) return "";  if ( jono  == NULL ) return tulos;  do {           /* K³yd³³n jonon kaikki merkit l³pi */    if ( jono[j] != '-' ) {      tulos[t++] = jono[j];      ONKO_LOPETUS;    }    else {       /* Lis³t³³n v³liss³ olevat merkit   */      if ( mista == NULL ) { /* ASCII-t³yttä         */        seuraava = jono[j+1]; if (seuraava==0) seuraava = 256;        for (c=edellinen+1; c<seuraava; c++) {          tulos[t++] = (char)c;          ONKO_LOPETUS;        }      }      else { /* t³ytet³³n mista-jonosta              */        seuraava  = paikka(mista,jono[j+1]);          if ( jono[j+1] == 0 ) seuraava = strlen(mista);        ed = paikka(mista,edellinen);        if ( j == 0 || ed >= 0 )          for (c=ed+1; c<seuraava; c++) {            tulos[t++] = mista[c];            ONKO_LOPETUS;          }      }    }            /* Lis³t³³n v³liss³ olevat merkit   */    edellinen = jono[j];  } while ( jono[j++] );/* K³yd³³n jonon kaikki merkit l³pi */  return tulos;#undef ONKO_LOPETUS}/****************************************************************************/int                       /* 0, jos jokin jonoista                          */joku_jono_func(           /* 1  jos ei ole                                  */  const char *s,          /* s  Tutkittava jono                             */  const char *mista,      /* s  Jonot, joista etsit³³n                      */  const char *erottimet,  /* s  Erotinmerkit                                */  str_2_fun  vertaa       /* s  Mill³ funktiolla jonona verrataan           */)/* Palautetaan 0 , jos s on jokin jonon mista osista. Osat erotetaan** toisistaan EROTTIMET-merkeill³.** Esim. "EY"  "E?|USA" "|,"   -> 0**       "SU"  "EU|EY|EL" "|," -> 1** Kutsuu: palanen  -> ei saa k³ytt³³ kesken paloittelun!----------------------------------------------------------------------------*/{  if ( mista == NULL || s == NULL || erottimet == NULL ) return 1;{  char *m=tee_jono(mista),*p,*o=m;  int j,paluu=1;  /* Oletus: Ei ole                                         */  do {    p = palanen(o,erottimet,&j);    o = NULL;    if ( vertaa(s,p) == 0 ) { paluu = 0; break; }  } while ( j > 0 );  free(m);  return paluu;}}/****************************************************************************/int                       /* 0, jos jokin jonoista                          */joku_jono(                /* 1  jos ei ole                                  */  const char *s,          /* s  Tutkittava jono                             */  const char *mista,      /* s  Jonot, joista etsit³³n                      */  const char *erottimet   /* s  Erotinmerkit                                */)/* Palautetaan 0 , jos s on jokin jonon mista osista. Osat erotetaan** toisistaan EROTTIMET-merkeill³.** Esim. "EY"  "EU|EY|EL" "|," -> 0**       "SU"  "EU|EY|EL" "|," -> 1** Kutsuu: palanen  -> ei saa k³ytt³³ kesken paloittelun!----------------------------------------------------------------------------*/{  return joku_jono_func(s,mista,erottimet,strcmp);}/****************************************************************************//* arvosana.c *//***  Aliohjelmia arvosanojen k³sittelemiseksi muotojen 8.25 ja 8+**  v³lill³.**  Vesa Lappalainen 27.4.1993*/#include <math.h>typedef struct Muunnos_tyyppi {  char    merkki;  /* merkki joka jonon per³ss³ +,-,Ç tai NUL               */  double  ero;     /* ero kokonaislukuun      esim.  0.25                   */  int     lisa;    /* takaisin muunnoksessa kokonaislukuun lis³tt³v³ luku   */                   /* ja muunnoksessa v³hennett³v³ luku                     */                   /*  esim. 4+  -> kok.osa 4 , merkki + ero 0.25 lisa 0    */                   /*        5-  -> kok.osa 4 , merkki - ero 0.75 lisa 1    */} Muunnos_tyyppi;const                /*  01234567890123"   */char *ARVOSANA_MERKIT = "0123456789.-+Ç";/* Arvosanaan sallitut merkit.     *//****************************************************************************/staticMuunnos_tyyppi MUUNNOS[] = { /* HT: lis³³ ominaisuus 5# = 5.33              */  {'-',  0.75, 1 },          /*                      5@ = 4.66              */  {'+',  0.25, 0 },  {'Ç',  0.50, 0 },          /* puoli (HUOM! tulosteissa puoli ei v³lt. n³y)*/  {  0,  0.00, 0 }           /* Taulukon loppu jos kaikki alkiot 0          */};/****************************************************************************/double                    /*                                                */jono_arvosanaksi(         /*                                                */  const char *s           /* s   Arvosanaksi muutettava jono                */)/*** Funktiolla muutetaan jono 5+ arvosanaksi 5.25 jne.**** Algoritmi:  1. otetaan numero-osa**             2. jos lopussa -  v³hennet³³n 1 ja lis³t³³n 0.75**                jos lopussa Ç  lis³t³³n 0.5**                jos lopussa +  lis³t³³n 0.25**             (hoidetaan taulukolla)**** Muutettu toimimaan useammalla  per³kk³isell³ +,- tai Ç -merkill³.**** Esimerkki:         s    palautus**                  ----------------**                    5    5.00**                    5-   4.75**                    5Ç   5.5**                    5+   5.25**                    5.25 5.25**                    ""   0.00**                    hyl  0.00**                    kiit 0.00**                    5++  5.5**                    +    0.25**                    Ç    0.5**                    -    -0.25  // erikoistapaus**                    -+   -0.25**                    -Ç   -0.5**                    -2Ç  -2.5**                    -3-  -2.75----------------------------------------------------------------------------*/{  double d=0.0;  const  char *merkki;  int    l = strlen(s);  int    i;  int    pit=0;  int    etum = 1;  if ( l == 0 ) return 0.0;  if ( l == 1 )          /* Onko pelkk³ +,- tai Ç */    for (i=0; MUUNNOS[i].merkki != 0; i++ )      if ( MUUNNOS[i].merkki == s[0] )        return (MUUNNOS[i].ero - MUUNNOS[i].lisa);  if ( s[0] == '-' ) { pit++; etum *= -1; } /* etumerkki pois */  if ( s[0] == '+' ) { pit++; etum = 1; }   /* etumerkki pois */  sscanf(s+pit,"%lf",&d);  for (i=pit; s[i] && strchr("0123456789.",s[i]); i++,pit++);  for ( merkki=s+pit; *merkki; merkki ++) {    for (i=0; MUUNNOS[i].merkki != 0; i++)      if ( MUUNNOS[i].merkki == *merkki ) break;    d += (MUUNNOS[i].ero - MUUNNOS[i].lisa);  }  return etum * d;}/****************************************************************************/char *                    /*                                                */arvosana_jonoksi(         /*                                                */  double d,               /* s   Jonoksi muutettava arvosana                */  char   *nolla           /* s   Nollasta palautettava jono.                */)                         /*     Jos NULL, palautetaan "0"                  *//*** Funktiolla muutetaan reaaliluku 5.25 jonoksi 5+ jne.**** HUOM!       Aliohjelman palauttamaan osoitteeseen EI SAA kopioida**             mit³³n!   Osoitetta saa k³ytt³³ vain tuloksen ottamiseen**             ko. osoitteesta!** Algoritmi:  1.  Jos 0 niin palautetaan ""**             2.  katsotaan ero kokonaislukuun**             3.  jos ero 0.25 l³tk³st³³n kokonaisluvun per³³n +**                 jos     0.5      Ç**                 jos ero 0.75 yksi lis³³ kok.lukuun ja per³³n -**** Esimerkki:  palautus  <-  d**             --------------------**                    5    5.00**                    5-   4.75**                    5Ç   5.5**                    5+   5.25**                    5.25 5.25**                   nolla 0.00**                    +    0.25**                    -   -0.25**                   -2Ç  -2.5----------------------------------------------------------------------------*/{  int    etum   = d<-0.25001 ? -1 : 1;  /* etum, -0.25 erikoistapaus!       */  double dp     = etum*d;               /* d positiivisena                  */  int    koko   = (int)floor(dp);  int    i;  double ero    = dp - koko; /* Paljonko d heitt³³ kokonaisluvusta.         */  char   merkki = 0;         /* Jos merkki³ ei läyd. -> jono 5 NUL NUL -> OK*/  static char   jono[20];    /* Tarkkana jotta 20 riitt³³ sprintf:ss³       */  if ( d == 0 ) return ( nolla ? nolla : "0" );  for (i=0; MUUNNOS[i].ero != 0.0; i++)    if ( fabs(MUUNNOS[i].ero - ero ) <= 0.000001  ) {      koko   += MUUNNOS[i].lisa;      merkki  = MUUNNOS[i].merkki;    }  if ( koko == 0 ) /* 0-, 0+ ja 0Ç erikoistapauksena */    sprintf(jono,"%c",merkki);  else    sprintf(jono,"%d%c",koko,merkki);  if ( etum < 0 && jono[0] != '-' ) lisaa_alkuun(N_S(jono),"-");  return jono;}/****************************************************************************/int                       /* -1 kaikki merkit sallituissa merkeiss³         */sallituissa(              /* >0 n³in mones merkki ei sallituissa.           */  const char *jono,       /*  s tutkittava jono                             */  const char *sallitut    /*  s sallitut merkit                             */)/*** Palautetaan -1,  mik³li jonon jokainen kirjain on sallituissa** muuten ensimm³isen virheellisen merkin indeksi----------------------------------------------------------------------------*/{  int i;  if ( jono == NULL )     return -1;  if ( sallitut == NULL ) return 0;  for (i=0; jono[i]; i++ )    if ( strchr(sallitut,jono[i]) == NULL ) return i;  return -1;}/****************************************************************************/char                      /*                                                */*poista_merkit(           /* =   Muutettu jono                              */  char *jono             ,/* s,t Muutettu jono                              */  const char *mitka       /* s   Poistettavat merkit                        */)/*** Funktiolla poistetaan merkkijonosta kaikki jonossa mitka olevat merkit**** Algoritmi: K³ytet³³n kahta osoitinta luku ja kirjoitus,**            Merkki kopioidaan lukupaikasta kirjoituspaikkaan kun**            ei ole poistettava.**            luku-osoitinta siirret³³n aina eteenp³in.** Esimerkki: "k    is   sa" -> "kissa"**              ^   ^**              k   l----------------------------------------------------------------------------*/{  char *l=jono,*k=jono;  if ( jono == NULL ) return "";  while (*l) {    if ( strchr(mitka,*l) == NULL ) { /* Jollei poistettava, kopioidaan     */      *k=*l; k++;    }    l++;  }  *k = 0;  return jono;}/****************************************************************************/char *                    /*                                                */poista_alusta(            /* =   Muuttunut jono                             */  char *s,                /* s,t Jono josta poistetaan merkkej³.            */  int n                   /* s   Montako merkki³ poistetaan.                */)/*** Funktiolla poistetaan merkkijonosta annettu m³³r³ merkkej³.** Ei haittaa vaikka n > jonon pituus.**                ** Esimerkki: s = "Kivaa"  n = 2  => s = "vaa"**----------------------------------------------------------------------------*/{  int i=0;  if ( s == NULL ) return "";  /* Jos poistetaan enemm³n merkkej³ kuin jonon pituus                      */  if ( strlen(s) <= n ) { s[0] = 0; return s; }  while ( ( s[i] = s[i+n] ) != 0 ) i++;  return s;}/****************************************************************************/int                       /* 0 = Onnistui                                   */lisaa_alkuun(             /* muut ei mahdu                                  */  char *s,                /* s,t Muutettava jono                            */  int maxp,               /* s   Jonon maksimipituus                        */  const char *k           /* s   Lis³tt³v³ jono                             */)/*** Funktiolla lis³t³³n jonon alkuun toinen jono.** Jos ei mahdu, s lyhenee lopusta p³in.**** Esimerkki:                                         01234567890**   s = "Kivaa",  maxp = 10, k = "T³m³ on "  => s = "T³m³ on Ki"  => -1**----------------------------------------------------------------------------*/{  int lk=strlen(k);  int ls=strlen(s);  int i;  if ( k == NULL ) return 0;  if ( s == NULL ) return -1;  for (i=ls; i>=0; i--) { /* Tehd³³n tyhj³³ jonon alkuun                    */    if ( i+lk >= maxp-1 ) s[maxp-1] = 0;    else s[i+lk] = s[i];  }  for (i=0; k[i]; i++) {  /* Uusi jono tyhj³n p³³lle                        */    if ( i >= maxp-1 ) { s[maxp-1] = 0; break; }    s[i] = k[i];  }  if ( lk+ls+1 > maxp ) return -1;  return 0;}/****************************************************************************/char *                    /*                                                */lisaa_merkki(             /* = muuttunut jono                               */  char *s,                /* s,t Muutettava jono                            */  int maxp,               /* s   Jonon maksimipituus                        */  char c,                 /* s   Lis³tt³v³ merkki                           */  int mihin               /* s   Paikka johon lis³t³³n                      */)/*** Funktiolla lis³t³³n jonon kohtaan paikka merkki c.** Jos ei mahdu, s lyhenee lopusta p³in.**** Esimerkki:                                          01234567890**   s = "Kiaa", maxp = 10, c = 'v', paikka=2  => s = "Kivaa"**----------------------------------------------------------------------------*/{  char lisa[2];  lisa[0]=c; lisa[1]=0;  if ( maxp <= mihin ) return s;  lisaa_alkuun(s+mihin,maxp-mihin,lisa);  return s;}/****************************************************************************/char *vaihda_jonot(char *p, int n, const char *mika, const char *milla)/*** Jos mika-jonon alussa on ^- tarkoitetaan etta vaihto tehdaan vain rivin** alusta.  Muuten kaikki esiintymat vaihdetaan.**** Esimerkki:**    mika    milla    p              ->   p**    "Aku"   "Tupu"   "Ankka Aku"         "Ankka Tupu"**    "^Aku"  "Tupu"   "Ankka Aku"         "Ankka Aku"**    "^Aku"   "Tupu"  "Aku Ankka"         "Tupu Ankka"**    "Aku"    "Tupu"  "Aku Akunen"        "Tupu Tupunen"**    "^Aku"   "Tupu"  "Aku Akunen"        "Tupu Akunen"----------------------------------------------------------------------------*/{  const char *miksi = (milla ? milla : "");  int p_mika;  int p_miksi = strlen(miksi);  int i;  int vain_alku = 0;  if ( p == NULL  || mika == NULL ) return p;  if ( mika[0] == '^' ) { mika++; vain_alku = 1; }  p_mika = strlen(mika);  for (i=0; p[i] && i<n && !( i > 0 && vain_alku ) ; i++) {    if ( strncmp(p+i,mika,p_mika) != 0  ) continue;    poista_alusta(p+i,p_mika);    lisaa_alkuun(p+i,n-i,miksi);    i += p_miksi-1;  }  return p;}/****************************************************************************/char *vaihda_merkit(char *s,int n,char mika, char miksi){  int i;  if ( s == NULL ) return s;  for (i=0; i<n; i++)    if ( s[i] == mika ) s[i] = miksi;  return s;}/****************************************************************************//****************************************************************************/typedef struct {  char from;  char to;} tCMuunnos;tCMuunnos CPreChars[] = {  { 'n' , '\n' },  { 'r' , '\r' },  { 't' , '\t' },  { 'b' , '\b' },  { 'a' , '\a' },  { '\\', '\\' },  { 0   , 0    }};/****************************************************************************/char CPrefix(char **p)/*** Tekee jonolle CPrefix-muunnoksen, eli \ unohdetaan ja seuraava osa** tulkitaan. Osoitin palautetaan siten, ett jonon ohi pstn kun** seuraavaksi listn osoitinta viel yhdell.** Toistaiseksi osataan vain heksaluvut, ei oktaaleja.** Esim "\0x61"**     *p^****  => a ja "\0x61"**             *p^**--------------------------------------------------------------------------*/{  int i,j;  char *s;  if ( *p == NULL )  return 0;  if ( **p != '\\' ) return **p;  (*p)++;  for (i=0; CPreChars[i].from; i++)    if ( **p == CPreChars[i].from ) return CPreChars[i].to;  if ( **p != '0' ) return **p;  if ( *((*p)+1) != 'x' ) return 0;  (*p) += 2; /* x: seuraava, OK vaikka 0 */  s = *p;  j = 0;  while ( isxdigit(**p) && j<2 ) { (*p)++; j++; }  sscanf(s,"%2x",&i);  (*p)--;  return (char)i;}/****************************************************************************/int muunna_C_symbolit(char *s){  char *p = s;  int i;  if ( p == NULL ) return 0;  for (i=0;*p;p++) {    if ( *p == '\\' ) { s[i++] = CPrefix(&p); continue; }    s[i++] = *p;  }  s[i] = 0;  return 0;}/****************************************************************************/char *jonossa_vain_merkit(char *s,const char *merkit){  int n;  if ( merkit == NULL || s == NULL ) return s;  while ( ( n = sallituissa(s,merkit) ) >= 0 )    poista_alusta(s+n,1);  return s;}