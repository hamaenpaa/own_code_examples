#include<stdio.h>#include<string.h>#include<dos.h>#include<alloc.h>// Nimiarvoparitaulukko 1. indeksi nimiarvoparin indeksi//                      2. indeksi 0=nimi, 1=arvochar nimiarvop[7][2][30];// Tietuetyypitstruct tagit { char tagi[255]; int jarjnro ; struct tagit *seur; } yy;struct nimiarvot { char knimi[30]; char arvo[30]; int jarjnro;  struct nimiarvot *seur; } xx;struct nimet { char knimi[30]; int jarjnro; struct nimet *seur; } zz;// Ohjelmatvoid viedata( void *os , void *data , int maxp ){  size_t pituus;  movedata( FP_SEG(data) , FP_OFF(data) , FP_SEG(os) , FP_OFF(os) , maxp );}void tuodata( void *os , char *data , int maxp ){  movedata( FP_SEG(os) , FP_OFF(os) , FP_SEG(data) , FP_OFF(data) , maxp );}void kopioi_osastr( char *kohde , char *rivi , int alku , int pituus )// Kopioi merkkijonoon kohde merkkijonosta rivi kohdalta alku// pituus -m³³r³n merkkej³{  int i;  for( i=alku ; i<=alku+pituus-1 ; i++ ) { kohde[i-alku] = rivi[i]; }    kohde[pituus]='\0';}void kelaa_lainausmerkit( char *rivi , int *merkki )// Etsii seuraavan lainausmerkin kohdan *merkki j³lkeen.// *merkki palautuu kutsuvaan ohjelmaan.{  (*merkki)++;  while(rivi[*merkki]!='"') { (*merkki)++; }}void seur_tagi( char *rivi , char *tagi , int *merkki , int *loytyi ,int *kesken , int *option )// Hakee seuraavan tagin tai sen osan merkkijonosta rivi ja palauttaa sen// merkkijonossa tagi. *merkki on kohta, josta tagin etsiminen// aloitetaan ja se palautuu kutsuvaan ohjelmaan tagin viimeisen// merkin kohtana. Parametrissa *loytyi kutsuva ohjelma saa tiedon// siit³, onko tagi läytynyt merkkijonosta rivi myäskin siin³// tapauksessa, ett³ kyse on edelliselt³ rivilt³ jatkuvasta tagista.// Parametri *kesken ilmaisee sen, jos rivi ei sis³ll³ koko tagia,// vaan sen osan. Jos se aliohjelmaa kutsuttaessa on nollasta// poikkeava, ohjelma tiet³³, ett³ rivi alusta alkaen on// edellist³ keskenj³³nytt³ tagia.{  int alku,loppu,pituus;  pituus=strlen(rivi);(*loytyi)=0;  if (*kesken) alku=0; else    while( (rivi[*merkki] != '<') && ((*merkki)<=pituus)) { (*merkki)++; }  if ((*merkki) < pituus )    {      (*loytyi)=1;      if ( (!option) && (rivi[*merkki] == '<') &&	   ( ( strncmp( rivi+(*merkki) , "<option" ,7 )==0 ) ||	     ( strncmp( rivi+(*merkki) , "<OPTION" ,7 )==0 ) ) )	     { (*option)=1;(*merkki)=(*merkki)+6; }      if (*option) {	while( ( ( strncmp( rivi+(*merkki) , "<option" , 7 ) == 0 ) ||		 ( strncmp( rivi+(*merkki) , "<OPTION" , 7 ) == 0 ) ||		 ( strncmp( rivi+(*merkki) , "</select" , 7 ) == 0 ) ||		 ( strncmp( rivi+(*merkki) , "</SELECT" , 7 ) == 0 ) ) &&		 ( (*merkki) < pituus ) ) (*merkki)++;	if ( (*merkki) < pituus ) { loppu=(*merkki)-1;(*merkki)--;				    (*option)=0; }	  else { (*kesken)=1; }      } else {      alku = *merkki;      while( (rivi[*merkki] != '>' ) && ((*merkki) <= pituus) )	{	  if (rivi[*merkki] == '"') { kelaa_lainausmerkit( rivi , merkki ); }	  (*merkki)++;	}      loppu=*merkki;if (rivi[*merkki] == '>') (*kesken)=0; else (*kesken)=1;      }    }  if (*loytyi) kopioi_osastr( tagi , rivi , alku , loppu-alku+1 );}struct tagit* lisaa_tagit( struct tagit *nyk , char *rivi , int *kesken ,char *tag , struct tagit **alku , int *taginro , int *option )// Ohjelma lis³³ osoittimen nyk osoittaman tagitietueen per³³n// merkkijonosta rivi läytyv³t tagit.// Parametri *kesken ilmaisee, jos merkkijonosta rivi läytyv³// tagi jatkuu seuraavalle riville. T³lläin merkkijono tag// pit³³ sis³ll³³n kertyneen tagin.{  struct tagit *uusi;  int merkki, loytyi;  char otag[255];  merkki=0;  while( merkki <= strlen( rivi ) ) {    seur_tagi( rivi , otag , &merkki , &loytyi , kesken , option );    if ( loytyi && (!(*kesken))) {      uusi = (struct tagit *)farmalloc( sizeof(struct tagit) );      if (uusi==NULL) {	printf("Muisti loppui!\n");      }      if (nyk!=NULL) nyk->seur = uusi;      if (strlen(tag)>0) tag[strlen(tag)-1]='\0';      strcat(tag,otag);      viedata( uusi-> tagi , tag , strlen(tag)+1 );      uusi->seur=NULL;      uusi->jarjnro = (*taginro);if (nyk==NULL) (*alku) = uusi;      nyk=uusi;tag[0]='\0';(*taginro)++;    }    if (*kesken) { tag[strlen(tag)-1]='\0';strcat(tag,otag); }  }  return nyk;}void kirj_nimiarvot( char *tiednimi , struct nimiarvot *alku , int jarjnro ){struct nimiarvot *nyk;FILE *TIEDOSTO;char tul[30];nyk=alku;TIEDOSTO = fopen( tiednimi , "w" );    while( nyk!=NULL ) {      tuodata( nyk->knimi , tul , 30 );      fprintf(TIEDOSTO,"%s \n",nyk->knimi );      tuodata( nyk->arvo , tul , 30 );      fprintf(TIEDOSTO,"%s \n",nyk->arvo);      if ( jarjnro ) fprintf(TIEDOSTO,"%d \n",nyk->jarjnro );      nyk=nyk->seur;    }fclose(TIEDOSTO);}void kirj_nimet( char *tiednimi , struct nimet *alku , int jarjnro ){struct nimet *nyk;FILE *TIEDOSTO;char tul[30];nyk=alku;TIEDOSTO = fopen( tiednimi , "w" );    while( nyk!=NULL ) {      tuodata( nyk->knimi , tul , 30 );      fprintf(TIEDOSTO,"%s \n",nyk->knimi );      if ( jarjnro ) fprintf(TIEDOSTO,"%d \n",nyk->jarjnro );      nyk=nyk->seur;    }fclose(TIEDOSTO);}void kirj_nimet_ja_nimiarvot( char *tavktdyhd , struct nimet *nimialku ,			      struct nimiarvot *nimiarvoalku ,			      int jarjnro ){   FILE *TIEDOSTO;   int nimiarvo;   char tul[30];   TIEDOSTO=fopen( tavktdyhd , "w" );    while( ( nimialku != NULL ) || ( nimiarvoalku != NULL ) ) {     if ( nimialku == NULL ) { nimiarvo=1; }     if ( nimiarvoalku == NULL ) { nimiarvo=0; }     if ( ( nimialku !=NULL ) && ( nimiarvoalku != NULL ) ) {       if ( nimiarvoalku->jarjnro < nimialku->jarjnro ) { nimiarvo=1; }	 else { nimiarvo=0; }     }     if (nimiarvo) {       tuodata( nimiarvoalku->knimi , tul , 30 );       fprintf(TIEDOSTO,"%s \n",tul );       tuodata( nimiarvoalku->arvo , tul , 30 );       fprintf(TIEDOSTO,"%s \n",tul );       if ( jarjnro ) fprintf(TIEDOSTO,"%d \n",nimiarvoalku->jarjnro );       nimiarvoalku = nimiarvoalku->seur;     } else {       tuodata( nimialku->knimi , tul , 30 );       fprintf(TIEDOSTO,"%s \n", tul );       if ( jarjnro ) fprintf(TIEDOSTO,"%d \n",nimialku->jarjnro );       nimialku=nimialku->seur;     }   }}void kirj_tiedosto( char *tiednimi , struct tagit *alku , int jarjnro )// Kirjoittaa tagilistan, johon osoitin alku osoittaa// tiedostonimelle tiednimi.{struct tagit *nyk;FILE *TIEDOSTO;char tul[255];nyk=alku;TIEDOSTO = fopen( tiednimi , "w" );    while( nyk!=NULL ) {      tuodata( nyk->tagi , tul , 255 );      fprintf(TIEDOSTO,"%s \n",nyk->tagi);      if ( jarjnro ) fprintf(TIEDOSTO,"%d \n",nyk->jarjnro);      nyk=nyk->seur;    }fclose(TIEDOSTO);}int inptype( char *tagi , char *tyyppi )// Tutkii, onko tagi merkkijonon tyyppi osoittama input-type{  int i,pituus,loytyi,lainaus;  i=6;pituus=strlen(tagi);loytyi=0;lainaus=0;  while( ( i < pituus-4 ) && (!loytyi) )    {      if ( strncmpi( (tagi)+i, "type", 4 )==0 ) loytyi=1;      i++;    }  i=i+3;  if (loytyi) while( (i<pituus) && (tagi[i]==' ') ) i++;  if ((loytyi) && (tagi[i]!='=')) loytyi=0; else i++;  if (loytyi) while( (i<pituus) && (tagi[i]==' ') ) i++;  if ((loytyi) && (tagi[i]=='"')) { lainaus=1;i++; }  if (loytyi && (strncmpi( (tagi)+i,tyyppi,strlen(tyyppi) )!=0) ) loytyi=0;  i=i+strlen(tyyppi);  if (loytyi && lainaus) while( (i<pituus) && (tagi[i]!='"') ) i++;  if (loytyi && lainaus && (tagi[i]!='"') ) loytyi=0;  if (loytyi) return 1; else return 0;}int radio(  char *tagi )// Tutkii, onko tagi radio{  if ( (strncmpi(tagi,"<input",6)==0) &&       ( inptype(tagi,"radio") || inptype(tagi,"RADIO") ) ) return 1;  else return 0;}int chbox( char *tagi )// Tarkistaa, onko tagi checkbox-kentt³{  if ( (strncmpi(tagi,"<input",6)==0) &&       ( inptype(tagi,"checkbox") || inptype(tagi,"CHECKBOX")))  return 1;  else return 0;}int textarea( char *tagi )// Tarkistaa, onko tagi textarea-tyyppi³{  if (strncmpi(tagi,"<textarea",9)==0) return 1; else return 0;}int intag( char *tagi )// Tarkistaa, onko tagi input-tyyppi³{  if (strncmpi(tagi,"<input",6)==0) return 1; else return 0;}int onnappula( char *tagi ){  if ( (strncmpi(tagi,"<input",6)==0) &&       ( inptype(tagi,"submit") || inptype(tagi,"SUBMIT") ||	 inptype(tagi,"reset")  || inptype(tagi,"RESET") ) )  return 1; else return 0;}int textkentta( char *tagi ){  if ( (strncmpi(tagi,"<input",6)==0) &&       ( inptype(tagi,"text") || inptype(tagi,"TEXT")) ) return 1;  if ( intag(tagi) && (!chbox(tagi)) && (!radio(tagi)) && (!onnappula(tagi)) )     return 1;  return 0;}int selc( char *tagi ){  if ( ( strncmpi(tagi,"<select",7)==0 ) ||       ( strncmpi(tagi,"<SELECT",7)==0 ) ) return 1; else return 0;}int kentta( char *tagi )// Tarkistaa, onko tagi kentt³{  if ( intag( tagi ) || textarea( tagi ) || selc( tagi ) ) return 1;    else return 0;}int muutavk( char *tagi )// Tarkistaa, onko tagi muu kentt³ kuin checkbox tai textarea tai nappula// tai radio.{  if ( kentta(tagi) && (!onnappula(tagi)) && (!chbox(tagi)) &&       (!radio(tagi)) && (!textarea(tagi)) ) return 1; else return 0;}int tavk( char *tagi )// Tarkistaa, onko tagi muu kentt³ kuin textarea tai nappula{   if ( kentta(tagi) && (!onnappula(tagi)) && (!textarea(tagi)) ) return 1;     else return 0;}void hae_edel_sana( char *rivi , char *nimi , int kohta ){  int alku,loppu;  loppu=kohta-1;  while( ( rivi[loppu] == ' ') && (loppu>0) ) loppu--;  alku=loppu;  while( ( rivi[alku] != ' ' ) && (alku>0) ) alku--;  alku=alku+1;  kopioi_osastr( nimi , rivi , alku , loppu-alku+1 );}void hae_seur_sana( char *rivi , char *nimi , int kohta ){  int alku,loppu,pituus;  pituus=strlen(rivi);  alku=kohta+1;  while( ( rivi[alku] == ' ') && (alku<pituus) ) alku++;  loppu=alku;  if (rivi[alku]=='\"') {    alku=alku+1;loppu=alku;    while( ( rivi[loppu] != '\"' ) && ( loppu<pituus ) ) loppu++;    loppu=loppu-1;  }  else {    while( ( rivi[loppu] != ' ' ) && (loppu<pituus) ) loppu++;    loppu=loppu-1;  }  kopioi_osastr( nimi , rivi , alku , loppu-alku+1 );}void hae_seur_nimiarvo( char *rivi , int *merkki , char *nimi , char *arvo ){  int kohta,pituus;  kohta=*merkki;  pituus=strlen(rivi);  while( ( rivi[kohta] != '=' ) && ( kohta<pituus ) ) kohta++;  if ( kohta<pituus ) {    hae_edel_sana( rivi , nimi , kohta );    hae_seur_sana( rivi , arvo , kohta );    kohta++;while( rivi[kohta] == ' ' ) kohta++;    kohta=kohta+strlen(arvo);  }  (*merkki)=kohta;}void hae_nimiarvoparit( struct tagit *os , int *maara ){  int merkki,ind,pituus;  char tag[255];  merkki=0;ind=0;pituus=strlen( os->tagi );(*maara)=0;  while( merkki < pituus ) {    tuodata( os->tagi , tag , 255 );    hae_seur_nimiarvo( tag , &merkki , nimiarvop[ind][0] ,      nimiarvop[ind][1] );    ind++;  }  if ( ind >0 ) ind--;  (*maara) = ind;}struct nimiarvot *nimiarvoparit( struct tagit *alku ){  struct nimiarvot *os,*osedel,*nmalku;  int maara,loytyi,ind;  os=osedel=NULL;nmalku=NULL;  while( alku != NULL )    {       hae_nimiarvoparit( alku , &maara );       if ( maara > 0 ) {	 loytyi=0;ind=0;	 while( ( !loytyi ) && ( ind <= maara-1 ) )	   {	     if ( ( strcmp(nimiarvop[ind][0],"name")==0 ) ||		  ( strcmp(nimiarvop[ind][0],"NAME")==0 ) )	     {	       os = (struct nimiarvot *)farmalloc( sizeof(struct nimiarvot) );	       os->seur=NULL;os->jarjnro = alku->jarjnro;	       if ( osedel!=NULL ) { osedel->seur = os; }		 else { nmalku = os; }	       viedata( os->knimi , nimiarvop[ind][1] ,			strlen(nimiarvop[ind][1])+1 );	       loytyi=1;	     } else ind++;	   }	 if (loytyi)	   {	     loytyi=0;ind=0;	       // while	     while( ( !loytyi ) && ( ind <= maara-1 ) ) {	       if ( ( strcmp(nimiarvop[ind][0],"value")==0 ) ||		    ( strcmp(nimiarvop[ind][0],"VALUE")==0 )		  ) {		      viedata( os->arvo , nimiarvop[ind][1] ,			strlen(nimiarvop[ind][1])+1 );		      loytyi=1;		    } else ind++; } // while	     osedel=os;	   } // if (loytyi)       }   // if ( maara       alku=alku->seur;    } // while ( alku != NULL )  return nmalku;}struct nimet *nimilista( struct tagit *alku ){  struct nimet *os,*osedel,*osalku;  int maara,loytyi,ind;  os=osedel=osalku=NULL;  while( alku != NULL )    {       hae_nimiarvoparit( alku , &maara );       if ( maara > 0 )	 {	   loytyi=0;ind=0;	   while( ( !loytyi ) && ( ind <= maara-1 ) ) {	     if ( ( strcmp( nimiarvop[ind][0], "name" )==0 ) ||		  ( strcmp( nimiarvop[ind][0], "NAME" )==0 )		)	     {	       os = (struct nimet *)farmalloc( sizeof(struct nimet) );	       os->seur=NULL;os->jarjnro = alku->jarjnro;	       if ( osedel!=NULL ) { osedel->seur = os; }		 else { osalku = os; }	       viedata( os->knimi , nimiarvop[ind][1] ,			strlen(nimiarvop[ind][1])+1 );	       loytyi=1;	     } else { ind++; }	   }	   if ( loytyi ) { osedel=os; }	 }  // if ( maara       alku=alku->seur;    }  return osalku;}struct nimet *poista_tuplanimet( struct nimet *alku ){   char vert1[30],vert2[30];   struct nimet *edel,*nyk,*kelaus;   int sama;   edel=NULL;nyk=alku;   while( nyk != NULL ) {     if (edel==NULL) { edel=nyk;nyk=nyk->seur; } else {	kelaus=alku;sama=0;	tuodata( nyk->knimi , vert1 , 30 );	while( (!sama) && (kelaus!=nyk) ) {	  tuodata( kelaus->knimi , vert2 , 30 );	  if ( strcmp(vert1,vert2)==0 ) { sama=1; }	    else { kelaus=kelaus->seur; }	}	if (sama) { edel->seur=nyk->seur;farfree(nyk);nyk=edel->seur; }	  else { edel=nyk;nyk=nyk->seur; }     }   }   return alku;}struct nimet *nimetnimiarvoista( struct nimiarvot *nimiarvot ){  struct nimet *alku,*kelaus,*viim;  char vert1[30],vert2[30];  int eri,ensim;  alku=NULL;kelaus=NULL;viim=NULL;ensim=0;  while( nimiarvot != NULL ) {    kelaus=alku;eri=1;    tuodata(nimiarvot->knimi, vert2, 30 );    while((kelaus!=NULL)&&(eri)) {      tuodata(kelaus->knimi, vert1 , 30 );      if (strcmp(vert1,vert2)==0) { eri=0; }      kelaus=kelaus->seur;    }    if (eri) {      kelaus=viim;      viim=(struct nimet *)malloc(sizeof(struct nimet));      if (kelaus!=NULL) { kelaus->seur=viim; }      viedata(viim->knimi,vert2,30);      viim->jarjnro = nimiarvot->jarjnro;      viim->seur=NULL;      if (ensim==0) { ensim=1;alku=viim; }    }    nimiarvot=nimiarvot->seur;  }  return alku;}void muistia( FILE *MUISTI , char *viesti , int tiedindeksi ){  unsigned long muisti;  muisti = (unsigned long) farcoreleft();  fprintf( MUISTI , "%s , tiedostonumero %d\n", viesti , tiedindeksi );  fprintf( MUISTI , "Muistia j³ljell³ %lu \n", muisti );}void vapauta_nimet( struct nimet *alku ){ struct nimet *apu; while( alku != NULL ) { apu=alku;alku=alku->seur;farfree(apu); }}struct tagit *lista( struct tagit *alku , int tyyppi , int numertyyppi )// Palauttaa osoittimen tagilistasta poimittujen// tagien listaan, joita parametri tyyppi kuvaa, kts. switch -lause.// Parametri numertyyppi ilmoittaa, ker³t³³nkä tageista// j³rjestysnumerot (1) vai laitetaanko oma juokseva numerointi ( 0 ).{int onkentta,taginro;char tag[255];struct tagit *os,*edel,*kent;kent=NULL;edel=NULL;taginro=1;while( alku!= NULL )  {    tuodata(alku->tagi,tag,255);    switch (tyyppi) {     case 0 : onkentta=kentta(tag);break;     case 1 : onkentta=chbox(tag);break;     case 2 : onkentta=radio(tag);break;     case 3 : onkentta=textarea(tag);break;     case 4 : onkentta=muutavk(tag);break;     case 5 : onkentta=tavk(tag);break;    }    if (onkentta) {      os = (struct tagit*) farmalloc( sizeof(struct tagit) );      viedata(os->tagi,tag,255);      os->seur=NULL;      if (!numertyyppi) { os->jarjnro=taginro;taginro++; } else	 { os->jarjnro=alku->jarjnro; }      if (kent==NULL) { kent=os; } else edel->seur = os;      edel=os;    }    alku=alku->seur;  }  return kent;}void muodostatiednimet( char *lomake , char *lomaketied , char *tavtd ,			char *chtd   , char *tareatd , int tiedindeksi ){  char nroteks[4];  itoa( tiedindeksi , nroteks , 10 );  strcpy( lomaketied , lomake );strcat( lomaketied , nroteks );  strcat( lomaketied , ".htm" );  strcpy( tavtd , lomake );strcat( tavtd , nroteks );  strcat( tavtd , ".tav" );  strcpy( chtd , lomake );strcat( chtd , nroteks );  strcat( chtd , ".chv" );  strcpy( tareatd , lomake );strcat( tareatd , nroteks );  strcat( tareatd , ".ta" );}void vapauta_tagit( struct tagit *alku ){ struct tagit *apu; while( alku != NULL ) { apu=alku;alku=alku->seur;farfree(apu); }}void vapauta_nimiarvot( struct nimiarvot *alku ){ struct nimiarvot *apu; while( alku != NULL ) { apu=alku;alku=alku->seur;farfree(apu); }}void kirj_sarakeperustiedosto( char *juuri, struct nimet *muunimet,   struct nimet *radionimet, struct nimiarvot *chnimiarvot ,  int tiedindeksi ){  char nroteks[4],tdnimi[80],kn[30],kd[30];  FILE *tiedosto;  int jarjnro1,jarjnro2,jarjnro3;  itoa( tiedindeksi , nroteks , 10 );  strcpy( tdnimi , juuri );  strcat( tdnimi , nroteks );  strcat( tdnimi , ".sj" );  tiedosto = fopen( tdnimi , "w" );  while( (muunimet!=NULL) || (radionimet!=NULL) || (chnimiarvot!=NULL) ) {     if ( muunimet!=NULL ) { jarjnro1=muunimet->jarjnro; } else 			  { jarjnro1=10000; }    if ( radionimet!=NULL ) { jarjnro2=radionimet->jarjnro; } else 			    { jarjnro2=10000; }    if ( chnimiarvot!=NULL ) { jarjnro3=chnimiarvot->jarjnro; } else 			     { jarjnro3=10000; }    if ( (jarjnro1<jarjnro2) && (jarjnro1<jarjnro3) ) {         tuodata( muunimet->knimi , kn , 30 );                fprintf( tiedosto , "%s\n\n" , kn );      muunimet=muunimet->seur;    }    if ( (jarjnro2<jarjnro1) && (jarjnro2<jarjnro3) ) {         tuodata( radionimet->knimi , kn , 30 );                fprintf( tiedosto , "%s\n\n" , kn );      radionimet=radionimet->seur;    }    if ( (jarjnro3<jarjnro1) && (jarjnro3<jarjnro2) ) {         tuodata( chnimiarvot->knimi , kn , 30 );                fprintf( tiedosto , "%s\n" , kn );      tuodata( chnimiarvot->arvo , kd , 30 );      fprintf( tiedosto , "%s\n" , kd );      chnimiarvot=chnimiarvot->seur;    }  }  close( tiedosto );}void kirj_seliteperustiedosto( char *juuri, struct nimet *muunimet, struct nimet *radionimet, struct nimet *chnimet , int tiedindeksi ){  char nroteks[4],tdnimi[80],kn[30];  FILE *tiedosto;  int jarjnro1,jarjnro2,jarjnro3;  itoa( tiedindeksi , nroteks , 10 );  strcpy( tdnimi , juuri );  strcat( tdnimi , nroteks );  strcat( tdnimi , ".sej" );  tiedosto = fopen( tdnimi , "w" );  while( (muunimet!=NULL) || (radionimet!=NULL) || (chnimet!=NULL) ) {     if ( muunimet!=NULL ) { jarjnro1=muunimet->jarjnro; } else 			  { jarjnro1=10000; }    if ( radionimet!=NULL ) { jarjnro2=radionimet->jarjnro; } else 			    { jarjnro2=10000; }    if ( chnimet!=NULL ) { jarjnro3=chnimet->jarjnro; } else 			 { jarjnro3=10000; }    if ( (jarjnro1<jarjnro2) && (jarjnro1<jarjnro3) ) {         tuodata( muunimet->knimi , kn , 30 );                fprintf( tiedosto , "%s\n" , kn );      muunimet=muunimet->seur;    }    if ( (jarjnro2<jarjnro1) && (jarjnro2<jarjnro3) ) {         tuodata( radionimet->knimi , kn , 30 );                fprintf( tiedosto , "%s\n" , kn );      radionimet=radionimet->seur;    }    if ( (jarjnro3<jarjnro1) && (jarjnro3<jarjnro2) ) {         tuodata( chnimet->knimi , kn , 30 );                fprintf( tiedosto , "%s\n" , kn );      chnimet=chnimet->seur;    }  }  close( tiedosto );}void hae_seur_nimi_listoista( struct nimet **tareanimet , struct nimet **muunimet , struct nimet **radionimet , struct nimet **chnimet ,int *listanro , int *loppu, struct nimet **nimios ) {  (*loppu)=0;    switch( *listanro ) {      case 1: if ( (*tareanimet)!=NULL ) 	      { 		*nimios=*tareanimet;		*tareanimet=(*tareanimet)->seur;break;	      } else { (*listanro)++; }      case 2: if ( (*muunimet)!=NULL )             	      {		*nimios=*muunimet;		*muunimet=(*muunimet)->seur;break;	      } else { (*listanro)++; }      case 3: if ( (*radionimet)!=NULL )      	      {		*nimios=*radionimet;		*radionimet=(*radionimet)->seur;break;	      } else { (*listanro)++; }      case 4: if ( (*chnimet)!=NULL )      	      {		*nimios=*chnimet;		*chnimet=(*chnimet)->seur;	      } 	      else { (*loppu)=1; }	      break;    }}int samoissa( struct nimet *nimios , struct nimiarvot *samanimet ){  int sama;  char nimi1[30],nimi2[30];  sama=0;  tuodata( nimios->knimi, nimi1 , 30 );  while( (!sama) && (samanimet!=NULL) ) {    tuodata( samanimet->knimi, nimi2 , 30 );    if (strcmp(nimi1,nimi2)==0) { sama=1; } else      { samanimet=samanimet->seur; }  }  return sama;}void tutki_samat( FILE *muisti , char *juuri , struct nimet *tareanimet , struct nimet *muunimet , struct nimet *radionimet , struct nimet *chnimet , int tiedindeksi ){  int listanro,listanro2,loppu,loppu2,onjosama,ensim;  struct nimiarvot *samanimet,*viim,*uusi;  struct nimet *nimios,*nimios2,*alku1,*alku2,*alku3,*alku4;  struct nimet *kalku1,*kalku2,*kalku3,*kalku4;  char nimi1[30],nimi2[30],tdnimi[80],nroteks[4];  FILE *samatied;  samanimet=NULL;viim=NULL;listanro=1;loppu=0;  alku1=tareanimet;alku2=muunimet;alku3=radionimet;alku4=chnimet;  while( !loppu ) {    hae_seur_nimi_listoista( &tareanimet , &muunimet , &radionimet ,       &chnimet , &listanro , &loppu , &nimios );    onjosama = samoissa( nimios , samanimet );     if (!onjosama) {      listanro2=1;loppu2=0;      kalku1=alku1;kalku2=alku2;kalku3=alku3;kalku4=alku4;ensim=1;      while( !loppu2 ) {	hae_seur_nimi_listoista( &kalku1, &kalku2, &kalku3, &kalku4,				 &listanro2, &loppu2, &nimios2 );	if ( nimios2 != nimios ) { // nimios2	  tuodata( nimios->knimi , nimi1 , 30 );	  tuodata( nimios2->knimi, nimi2 , 30 );  	  if ( strcmp(nimi1,nimi2)==0 ) { // if strcmp	    if (ensim) { // ensim	      uusi = (struct nimiarvot *)farmalloc(sizeof(struct nimiarvot));	      uusi->seur=NULL;	      if (samanimet!=NULL) { viim->seur=uusi; } else 		{ samanimet=uusi; }	      viim=uusi;	      viedata(uusi->knimi,nimi1,30);ensim=0;	      itoa(listanro,nimi2,10);	      itoa(listanro2,nroteks,10);	      strcat(nimi2,",");strcat(nimi2,nroteks);	      viedata(uusi->arvo,nimi2,30);	    } else {	      tuodata(uusi->arvo,nimi1,30);	      if (strlen(nimi1)<=28) {		itoa(listanro2,nimi2,10);		strcat(nimi1,",");		strcat(nimi1,nimi2);		viedata(uusi->arvo,nimi1,30);	      }	    } // ensim	  } // if strcmp	} // nimios2      } // !loppu2    } // !onjosama  } // !loppu  if (samanimet != NULL ) {    printf( "Lomakkeella %d oli samoja kent³nnimi³.\n", tiedindeksi );    strcpy( tdnimi , juuri );    itoa(tiedindeksi,nroteks,10);    strcat( tdnimi , nroteks );strcat( tdnimi , ".sam" );    printf( "Tiedot on talletettu tiedostoon\n%s\n" , tdnimi );    kirj_nimiarvot( tdnimi , samanimet , 0 );    muistia( muisti , "Samojen keruun j³lkeen ", tiedindeksi );    vapauta_nimiarvot( samanimet );    muistia( muisti , "Samojen vapautuksen j³lkeen ", tiedindeksi );  }}void kirj_muut_kuin_checkboxit( char *lomake,struct nimet *muunimet, struct nimet *radionimet, int tiedindeksi ){  char tdnimi[80],nroteks[4],nimi[30];  FILE *tiedosto;  strcpy( tdnimi , lomake );  itoa( tiedindeksi , nroteks , 10 );  strcat( tdnimi , nroteks );strcat( tdnimi , ".mtd" );  tiedosto = fopen( tdnimi , "w" );  while( ( muunimet != NULL ) && ( radionimet != NULL ) ) {    if (muunimet->jarjnro > radionimet->jarjnro)      {	tuodata( muunimet->knimi , nimi , 30 );	fprintf(tiedosto,"%s\n", nimi );	muunimet=muunimet->seur;      }    else      {	tuodata( radionimet->knimi , nimi , 30 );	fprintf(tiedosto,"%s\n", nimi );	radionimet=radionimet->seur;      }  }  fclose(tiedosto);}int main(){  FILE *TIEDOSTO,*MUISTI; // Tiedostomuuttuja eri yhteyksiin  char lomake[80],lomaketied[80],tagitied[80],muutavtd[80],chtd[80];  char tareatd[80],tavtd[80],tavktdyhd[80];  int altiedi,loptiedi;  // Tagilistojen talletustiedosjen nimet.  char tag[255];  // Rivien kesken j³³v³n tagin s³ilytyspaikka.  char rivi[255]; // Luettu rivi html-koodista  int kesken; // Ilmaisee, jos tagi on mennyt yli seuraavalle riville  int tiedmaara,tiedindeksi,taginro,option;  struct tagit *nyk,*alku,*kentatl,*tavl,*muutavl,*chkentatl,*tareatagit;  struct tagit *radiotagit;  struct nimiarvot *chnimiarvot;  struct nimet *muunimet,*tareanimet,*chnimet,*radionimet;  // alku=osoitin tagilistan alkuun  // kentatl kentt³listan alkuun, chkentat checkbox-listan alkuun,  // textareal textarea-listan alkuun, radiol radio-listan alkuun ja  // textl text-listan alkuun.  // nyk=tageja ker³tt³ess³ k³ytetty osoitin viimeiseen  // läydettyyn tagiin tai NULL, jos ei läydetty.  // Luetaan lomaketiedoston nimi  printf("Anna lomaketiedostojen juuri :\n");  scanf("%s",lomake);  printf("Anna aloitusindeksi :");  scanf("%d",&altiedi);  printf("Anna lopetusindeksi :");  scanf("%d",&loptiedi);  MUISTI=fopen("muisti.txt","w");  for(tiedindeksi=altiedi;tiedindeksi<=loptiedi;tiedindeksi++) {    muodostatiednimet( lomake , lomaketied , tavtd , chtd ,		       tareatd , tiedindeksi );    // Ker³t³³n lomaketiedostosta tagit    muistia( MUISTI , "Alku" , tiedindeksi );    taginro=1;option=0;    TIEDOSTO=fopen(lomaketied,"r");      tag[0]='\0';nyk=NULL;      while( fgets(rivi,255,TIEDOSTO) != NULL )	nyk = lisaa_tagit( nyk , rivi , &kesken , tag , &alku , &taginro ,			   &option );    fclose(TIEDOSTO);    // Haetaan erilaiset kent³t ja kirjoitetaan niiden listat    // annetuille tiedostonimille.    muistia( MUISTI , "Tagien keruun j³lkeen " , tiedindeksi );    kentatl   = lista( alku , 0 , 0 );    muistia( MUISTI , "Kenttien keruun j³lkeen " , tiedindeksi );    vapauta_tagit( alku );    muistia( MUISTI , "Tagien vapautuksen j³lkeen " , tiedindeksi );    tareatagit = lista( kentatl , 3 , 0 );    muistia( MUISTI , "Textarea-tagien keruun j³lkeen ", tiedindeksi );    tareanimet = nimilista( tareatagit );    muistia( MUISTI , "Textarea-nimien keruun j³lkeen ", tiedindeksi );    vapauta_tagit( tareatagit );    muistia( MUISTI , "Textarea-tagien vapautuksen j³lkeen ", tiedindeksi );    kirj_nimet( tareatd , tareanimet , 0 );    tavl = lista( kentatl , 5 , 0 );    muistia( MUISTI , "Tavallisten kenttien keruun j³lkeen ", tiedindeksi );    kirj_tiedosto( tavtd , tavl , 1 );    vapauta_tagit( kentatl );    muistia( MUISTI , "Kentt³tagien vapautuksen j³lkeen " , tiedindeksi );    muutavl = lista( tavl , 4 , 1 );    muistia( MUISTI , "Muiden tavallisten kenttien tagien keruun j³lkeen ",		       tiedindeksi );    muunimet = nimilista( muutavl );    muistia( MUISTI , "Muiden tavallisten kenttien nimien keruun j³lkeen ", 		       tiedindeksi );    vapauta_tagit( muutavl );    muistia( MUISTI ,      "Muiden tavallisten kenttien tagien vapautuksen j³lkeen ", tiedindeksi );    radiotagit = lista( tavl , 2 , 1 );    muistia( MUISTI , "Radiotagien keruun j³lkeen ", tiedindeksi );    radionimet = nimilista( radiotagit );    muistia( MUISTI , "Radionimien keruun j³lkeen ", tiedindeksi );    vapauta_tagit( radiotagit );    muistia( MUISTI , "Radiotagien vapautuksen j³lkeen ", tiedindeksi );    poista_tuplanimet( radionimet );    muistia( MUISTI , "Radiotuplanimien vapautuksen j³lkeen ", tiedindeksi );    chkentatl = lista( tavl , 1 , 1 );    muistia( MUISTI , 	     "Checkbox-kenttien tagien keruun j³lkeen ", tiedindeksi );    vapauta_tagit( tavl );    muistia( MUISTI ,     "Tavallisten kenttien tagien vapautuksen j³lkeen ", tiedindeksi );    chnimiarvot = nimiarvoparit( chkentatl );    muistia( MUISTI ,     "Checkbox-kenttien nimiarvoparien keruun j³lkeen ", tiedindeksi );    vapauta_tagit( chkentatl );    muistia( MUISTI ,     "Checkbox-kenttien tagien vapautuksen j³lkeen ", tiedindeksi );    kirj_nimiarvot( chtd , chnimiarvot , 0 );    kirj_sarakeperustiedosto( lomake, muunimet, radionimet, chnimiarvot ,			      tiedindeksi );    chnimet=nimetnimiarvoista( chnimiarvot );    muistia( MUISTI ,     "Checkbox-kenttien nimien keruun j³lkeen ", tiedindeksi );    vapauta_nimiarvot( chnimiarvot );    muistia( MUISTI ,     "Checkbox-kenttien nimiarvoparien vapautuksen j³lkeen ", tiedindeksi );    kirj_seliteperustiedosto( lomake, muunimet, radionimet, chnimet ,			      tiedindeksi );    kirj_muut_kuin_checkboxit( lomake, muunimet, radionimet, tiedindeksi );    tutki_samat( MUISTI, lomake, tareanimet , muunimet , radionimet , 		 chnimet, tiedindeksi );    vapauta_nimet( muunimet );vapauta_nimet( tareanimet );    vapauta_nimet( radionimet );vapauta_nimet( chnimet );  }  fclose(MUISTI);  return 0;}